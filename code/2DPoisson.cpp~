#include <iostream>
#include <cmath>
#include <fstream>

class TwoDPoisson{

public:
  
  // Constructeur

  TwoDPoisson(const std::size_t m){
    
    m_ = m;
    h_ = 1./(m_+1);
    
    x_ = new double[m_];
    y_ = new double[m_];
    lambda_ = new double[m_];
    
    u_ = new double*[m_];
    uTilde_ = new double*[m_];
    f_ = new double*[m_];
    fTilde_ = new double*[m_];
    s_ = new double*[m_];
    buffer_ = new double*[m_];
  
    for(int i=0; i<m_; ++i){
      
      u_[i] = new double[m_];
      uTilde_[i] = new double[m_];
      f_[i] = new double[m_];
      fTilde_[i] = new double[m_];
      s_[i] = new double[m_];
      buffer_[i] = new double[m_];
    }

    // Remplissage des matrices F, S et vecteur lambda
    
    for(std::size_t i=0; i<m_; ++i){

      x_[i] = (i+1)*h_;
      y_[i] = (i+1)*h_;
      lambda_[i] = 4*std::pow(sin(0.5*(i+1)*M_PI*h_),2);
      
      for(std::size_t j=0; j<m_; ++j){
	s_[i][j] = sin((i+1)*(j+1)*M_PI*h_);
	f_[i][j] = 1.;
      }
    }

    // Produit matriciel buffer = F * S

    matricialDot(m_, buffer_, f_, s_);
    
    // Produit matriciel fTilde = S * buffer

     matricialDot(m_, fTilde_, s_, buffer_);

    // Produit Matrice*Matrice = UTilde_ij = 4*h^4 * fTilde_ij / (lambda_i + lambda_j)
   
    for(std::size_t i=0; i<m_; ++i){
      for(std::size_t j=0; j<m_; ++j){
	uTilde_[i][j] = 4*std::pow(h_,4)*fTilde_[i][j] / (lambda_[i] + lambda_[j]);	
      }
    }
    
    // Produit matriciel buffer =  utilde * S

    matricialDot(m_, buffer_, uTilde_, s_);

    // Produit matriciel U = S * buffer

    matricialDot(m_, u_, s_, buffer_);
    
  }
  
  // Destructeur
  
  ~TwoDPoisson(){

    delete [] x_;
    delete [] y_;
    delete [] lambda_;

    for(int i=0; i<m_; ++i){
      
      delete [] u_[i];
      delete [] uTilde_[i];
      delete [] f_[i];
      delete [] fTilde_[i];
      delete [] s_[i];
      delete [] buffer_[i];
    }

    delete [] u_;
    delete [] uTilde_;
    delete [] f_;
    delete [] fTilde_;
    delete [] s_;
    delete [] buffer_;
    
  }

  // Fonctions de classe

  void displayU() const{
    
    for(std::size_t i=0; i<m_; ++i){
      for(std::size_t j=0; j<m_; ++j){
	
	std::cout << u_[i][j] << " "; 
      }
      std::cout << std::endl; 
    }
  }

  void saveU(const char* filename) const{

    std::ofstream file(filename ,std::ios::trunc);
    
    for(std::size_t i=0; i<m_; ++i){
      for(std::size_t j=0; j<m_; ++j){
	
	file << x_[i] << " " << y_[i] << " " << u_[i][j] << std::endl;
      }
    }
    
    file.close();
  }
  
private:

  std::size_t m_;
  double h_;

  double * x_;
  double * y_;
  double * lambda_;
  
  double ** u_;
  double ** uTilde_;
  
  double ** f_;
  double ** fTilde_;
 
  double ** s_;

  double ** buffer_;

  // Fonctions de classes (privées);

  void matricialDot(const std::size_t m_, double ** &C, double ** &A, double ** &B) const{

    for(std::size_t i=0; i<m_; ++i){
      for(std::size_t j=0; j<m_; ++j){

	C[i][j] = 0;
	
  	for(std::size_t k=0; k<m_; ++k){
  	  C[i][j] += A[i][k]*B[k][j];
  	}
      }
    }  
  }
  
};

int main(int argc, char** argv){
  
  const std::size_t N = atoi(argv[1]);
  
  TwoDPoisson test(N);

  const char* filename = "../result.dat";
  test.saveU(filename);

  return 0; 
}
